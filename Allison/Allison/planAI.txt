This file contains information about good or bad point moves, how we plan to determine the next move, and how to determine which move the computer player should make.

FUNCTIONS:
	1. Looks at the board and the possble moves and decides which move is the best.
		a. Recursive --> checks the next two moves available (used in determining which move to make)
	2. Move the game board piece. 

HOW TO MAKE A MAX HEAP IN PYTHON:
	1. import heapq
	2. heapq.heapify_max(nameOfList)


Good Move:
	- Jumping another player (+1.0)
	- Avoiding being jumped (+.75)
	- Becoming a King (+1.5)
	- Blocking a jump (+.5)

Bad Move: 
	- Setting self up to be jumped (-1.0)

Neutral Move:
	- Neither being jumped nor jumping another piece (+0.0)


Pseudocode:
01 function minimax(node, depth, maximizingPlayer)
02     if depth = 0 or node is a terminal node
03         return the heuristic value of node

04     if maximizingPlayer
05         bestValue := −∞
06         for each child of node
07             v := minimax(child, depth − 1, FALSE)
08             bestValue := max(bestValue, v)
09         return bestValue

10     else    (* minimizing player *)
11         bestValue := +∞
12         for each child of node
13             v := minimax(child, depth − 1, TRUE)
14             bestValue := min(bestValue, v)
15         return bestValue 
