This file will contain information about how to implement the BST that simulates the computer player AI.

Alpha-Beta game tree search: 
	Resources:
		- https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning
		- http://gamedev.stackexchange.com/questions/30026/checkers-ai-algorithm

	Notes:
		- a search algorithm that seeks to decrease the number of nodes that the minimax algorithm to choose which nodes can be deleted
			- minimax algorithm: a recursive algorithm that chooses the next move; a value is associated with each position of the game, each position has a "score" of how good it would be to move to that position; goal is to make the move that maximizes the minimum value of the position resulting from the opponent's possible following moves 
		- stops evaluating a move when at least one possibility has been found that proves the move to be worse than a previously examined move 
		- returns the same move as the minimax algorithm, but gets rid of moves that cannot influence the final decision

** PSEUDOCODE FOR AB-SEARCH ** 
01 function alphabeta(node, depth, α, β, maximizingPlayer)
02      if depth = 0 or node is a terminal node
03          return the heuristic value of node
04      if maximizingPlayer
05          v := -∞
06          for each child of node
07              v := max(v, alphabeta(child, depth – 1, α, β, FALSE))
08              α := max(α, v)
09              if β ≤ α
10                  break (* β cut-off *)
11          return v
12      else
13          v := ∞
14          for each child of node
15              v := min(v, alphabeta(child, depth – 1, α, β, TRUE))
16              β := min(β, v)
17              if β ≤ α
18                  break (* α cut-off *)
19          return v

	Steps of the algorithm's evaluator function:
		1. search all possible moves and the outcomes of the possible moves (5-10 moves in the future, called branches)
		2. evaluate the position of each branch (how many moves ahead/behind am I?)
		3. make the move that gives it the best chance (the move that maximizes the possible value)
		4. search the tree and make the move 
	
	** essentially, the AB-tree search gives a point value to each position on each move of the game. The higher the point value, the better the move.

=====================================================================================
Making a BST in Python: possibly implement as a heap?
	Resources:
		- http://interactivepython.org/runestone/static/pythonds/Trees/SearchTreeImplementation.html
		- DS notes on heaps (push/pop)
	Classes needed:
		1. BST: references Node that is the root of the tree
			a. functions that create the tree, return the size of the tree, and return the root of the tree
		2. Node: constructor for the node will hold the value for each node and it's children
			a. functions that determine if the tree has left and right children

	Considering implementing as a heap that is updated (push/pop) after each move
		- max heap? the root node has the highest point value (aka is the best legal move?)
